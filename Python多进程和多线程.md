## 1.什么是进程/线程

众所周知，CPU是计算机的核心，它承担了所有的计算任务。而操作系统是计算机的管理者，是一个大管家，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。应用程序是具有某种功能的程序，程序运行与操作系统之上。

## 2.进程

进程时一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时需要的数据和工作区；程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。

## 3.线程

在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。

线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。一个进程可以拥有多个线程，而且属于同一个进程的多个线程间会共享该进行的资源。

## 4.进程与线程的区别

1. 一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。
2. 切换进程需要的资源比切换线程的要多的多。
3. 进程之间相互独立，而同一个进程下的线程共享程序的内存空间（如代码段，数据集，堆栈等）。某进程内的线程在其他进程不可见。换言之，线程共享同一片内存空间，而进程各有独立的内存空间

## 5.Python多进程和多线程选择

1. 在以IO操作为主的IO密集型应用中，多线程和多进程的性能区别并不大，原因在于即使在Python中有GIL锁的存在，由于线程中的IO操作会使得线程立即释放GIL，切换到其他非IO线程继续操作，提高程序执行效率。相比进程操作，线程操作更加轻量级，线程之间的通讯复杂度更低，建议使用多线程。

2. 如果是计算密集型的应用，尽量使用多进程或者协程来代替多线程。

引用[廖雪峰博客](https://link.zhihu.com/?target=https%3A//www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832360548a6491f20c62d427287739fcfa5d5be1f000)博客：

> 因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。**这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核**。

下面是引用[知乎](https://www.zhihu.com/question/23474039/answer/269526476)的讲解：

> Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。
>
> 对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。
>
> 1.设置GIL。
>
> 2.切换到一个线程去执行。
>
> 3.运行。
>
> 4.把线程设置为睡眠状态。
>
> 5.解锁GIL。
>
> 6.再次重复以上步骤。
>
> 对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。
>
> 我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。
>
> 难道就如此？我们没有办法在Python中利用多核？当然可以！刚才的多进程算是一种解决方案，还有一种就是调用C语言的链接库。对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。我们可以把一些 计算密集型任务用C语言编写，然后把.so链接库内容加载到Python中，因为执行C代码，GIL锁会释放，这样一来，就可以做到每个核都跑一个线程的目的！
>
> 可能有的小伙伴不太理解什么是计算密集型任务，什么是I/O密集型任务？
>
> 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
>
> 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。
>
> 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。
>
> IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。
>
> 综上，Python多线程相当于单核多线程，多线程有两个好处：CPU并行，IO并行，单核多线程相当于自断一臂。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。

## 6.代码分析

#### 6.1 计算密集型模拟

1. 开启两个python线程分别做一亿次加一操作，和单独使用一个线程做一亿次加一操作
2. 开启两个python进程分别做一亿次加一操作，和单独使用一个经常做一亿次加一操作

```python
import threading
from multiprocessing import Process
import time

def tstart(_str):
    var = 0
    for i in range(100000000):
        var += 1


if __name__ == '__main__':
	t1 = threading.Thread(target=tstart, args=('This is thread 1',))
	t2 = threading.Thread(target=tstart, args=('This is thread 2',))
	start_time = time.time()
	t1.start()
	t1.join()
	t2.start()
	t2.join()
	print("Two thread cost time: %s" % (time.time() - start_time))

	start_time = time.time()
	tstart("This is thread 0")
	print("Main thread cost time: %s" % (time.time() - start_time))
	print("******************************")
	p1 = Process(target=tstart, args=("1",))
	p2 = Process(target=tstart, args=("2",))
	start_time = time.time()
	p1.start()
	p2.start()
	p1.join()
	p2.join()
	print("Two process cost time: %s" % (time.time() - start_time))
	start_time = time.time()
	tstart("0")
	print("Current process cost time: %s" % (time.time() - start_time))

    
# 输入结果：
Two thread cost time: 7.62561297416687
Main thread cost time: 3.832775831222534
******************************
Two process cost time: 5.084405899047852
Current process cost time: 3.9833498001098633
```

**对比分析**

1. 对应多线程来说，由于GIL锁的存在，采用多线程，并不能有效的提升效率

2. 双进程并行执行和单进程执行相同运算代码，耗时基本相同，双进程耗时会稍微多一些，可能原因是进程创建和销毁会进行系统调用，造成额外的时间开销。

## 参考

[知乎，多线程](https://www.zhihu.com/question/23474039/answer/269526476 )

